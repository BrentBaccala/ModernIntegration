Comparison of open source computer algebra systems

Axiom
  doesn't use readline
  builtin hyperdoc is way behind HTML
  couldn't figure how to parse:
    integrand := x*((x^2*exp(2*x^2)-log(x+1)^2)^2) / ((x+1)*(log(x+1)^2 - x^2*exp(2*x^2))^2)


Maxima
  uses LISP-style function definition syntax

  MAXIMA function tex_displ(MLABEL %O14 EXPR)
    - fetch tex-environment - either "" (strings) OR tex-environment property on car OR *tex-environment-default*
    - print tex1(LABEL %O14) (minus 14 chars because of trailing \mathbb{false})
    - then print env around tex1(EXPR)

  MAXIMA function print(EXPR) calls displa for output


Sage
  struggling to do polynomial long division
    calls Maxima or Singular to do this
  implements algebraic closure of Q (QQbar)

  + fix latex printing on power series
  - subs should raise NotImplementedError if element not callable
  - subs should work recursively on complicated rings
  - option to specify how QQbar elements print
  - can't type convert between two slightly different NumberRings:
      Number Field in a with defining polynomial a^7 - 18
      Number Field in a with defining polynomial y^7 - 18
  - add map_coefficients method to Laurent series (Taylor, too?)


Macaulay 2
  doesn't implemente fraction fields over complicated (non-Z, non-Q) constant fields

Singular
  can't compute Riemann-Roch spaces in characteristic p
  can compute Hamber-Noether expansions (can this be converted to a Puiseux expansion?)

CoCoA
  C++ library


Macaulay 2 - Riemann-Roch space calculator (Noether-Brill algorithm ??)

completeLinearSystemOnNodalPlaneCurve=method()
completeLinearSystemOnNodalPlaneCurve(Ideal,List):=(J,D)->(
     singJ:=saturate(ideal jacobian J+J);
        -- adjoint ideal
     H:=ideal (mingens ideal(gens intersect(singJ,D_0)%J))_(0,0);
        -- a curve passing through singJ and D_0
     E0:=((J+H):D_0):(singJ^2); -- residual divisor
     if not(degree J *degree H - degree D_0 -2*degree singJ==degree E0)
        then error"residual divisor of has wrong degree";
     L1:=mingens ideal (gens truncate(degree H, intersect(E0,D_1,singJ)))%J;
     h0D:=(tally degrees source L1)_{degree H}; -- h^0 O(D)
     L:=L1_{0..h0D-1}; -- matrix of homogeneous forms, L/H =L(D) subset K(C)
     (L,(gens H)_(0,0)))

http://www2.macaulay2.com/Macaulay2/doc/Macaulay2-1.11/share/doc/Macaulay2/Macaulay2Doc/html/___Tutorial_co_sp__Divisors.html





a=QQ['a'].0
aRing = NumberField(a^2 + 1, 'a')

b=QQ['b'].0
bRing = NumberField(b^2 + 1, 'a')

aRing is bRing

aa=aRing.0
bb=bRing.0

bRing(aa)

def ringmap(x):
    # First map x from the polynomial ring down to its coefficent ring (a NumberField)
    x = x.parent()(x)
    # Then convert it to a polynomial and map to into numfield
    return x.polynomial()(numfield.gens()[0])


HOW TO CREATE A MAP BETWEEN TWO POLYNOMIAL RINGS INDUCED BY A MAP ON THEIR COEFFICIENTS

R.<a> = QQ[]
aRing = NumberField(a^2 + 1, 'a')
R.<b> = QQ[]
bRing = NumberField(b^2 + 1, 'a')

aRing2 = aRing['x']
bRing2 = bRing['x']

h = aRing.hom(bRing.gens())

h2 = aRing2.hom(h, bRing2)

DOESN'T WORK FOR LAURENT SERIES



BUG REPORT TO SHOW HOW SINGULAR RETURNS RESULTS IN WRONG FIELD

R.<b> = QQ[]
S = NumberField(b^7 - 18, 'a')

R.<x,y> = S[]
f = x + y

singular.lib('hnoether.lib')
hne = f._singular_().hnexpansion().sage()

hne[0][0].base_ring() is f.parent()



SAGE - SINGULAR IDEALS

rings/polynomial/multi_polynomial_ideal.py
  lines 558-592
  create Singular ideal
  lift generators into parent ring before str-ifying them for Singular

interfaces/singular.py
  lines 1957-1959
  converts Singular ideal to sage ideal

   1958             R = R or self.sage_global_ring()
   1959             return R.ideal([p.sage_poly(R) for p in self])

  if R is a quotient ring,
    p.sage_poly(R) can't be lifted into the base ring

  sage_poly:

   1779             p = MPolynomial_polydict(R,PolyDict(sage_repr,force_int_exponents=False,force_etuples=False))
   1780             if isinstance(R, MPolynomialRing_polydict):
   1781                 return p
   1782             else:
   1783                 return QuotientRingElement(R,p,reduce=False)

  what we get back is a QuotientRingElement containing an MPolynomial_polydict

  self.sage_global_ring() will return a quotient ring different from the one we started with
    its generators will be named 'x', 'y', 'z', instead of 'xbar', 'ybar', 'zbar'

  subs doesn't work because _call_ isn't defined on QuotientRingElement's
    (subs in RingElement returns self if _call_ isn't defined)


Sage univariate polynomial discriminant:

rings/polynomial/polynomial_modn_dense_ntl.pyx:    def discriminant(self):

rings/polynomial/polynomial_integer_dense_flint.pyx:    def discriminant(self, proof=True):
        r"""
        Return the discriminant of self, which is by definition

        .. MATH::

            (-1)^{m(m-1)/2} \mathop{\mathrm{resultant}}(a, a')/\mathop{\mathrm{lc}}(a),

        temp = ZZX_discriminant(&ntl_poly, proof)
rings/polynomial/polynomial_integer_dense_ntl.pyx:    def discriminant(self, proof=True):
        cdef ZZ_c* temp = ZZX_discriminant(&self.__poly, proof)

rings/polynomial/polynomial_quotient_ring.py:    def discriminant(self, v=None):
        Return the discriminant of this ring over the base ring. This is by
        definition the discriminant of the polynomial that we quotiented
        out by.
        return self.modulus().discriminant()

rings/polynomial/polynomial_element.pyx:    def discriminant(self):
   class Polynomial(CommutativeAlgebraElement)

Sage multivariate polynomial discriminant:

   cdef class MPolynomial_libsingular(MPolynomial):

rings/polynomial/multi_polynomial_libsingular.pyx:    def discriminant(self,variable):
        Returns the discriminant of self with respect to the given variable.



RIEMANN-ROCH BASIS

Singular: three methods
  brnoeth.lib (D.10.1) - ground field must be finite
     call NSplaces to get a list of non-singular places
     pass in a intvec to specify the order of the divisor at each place
  brillnoether.lib (D.15.2) - ground field must be Q
  hess.lib (D.15.19) - ground field must be Q
     pass in two fractional ideals - one for finite places, one for infinite places

Macaulay 2
  completeLinearSystemOnNodalPlaneCurve
     I guess this only works on a nodal curve?
     input specified as a pair of ideals of coordinate ring (Weil divisor)

KASH - finite fields, QQ, number fields

Sage
  not implemented at all in standard distribution
  implemented for finite fields in klee's Trac #22982
  via Kash for QQ and number fields (my code)

Note for a native Sage implementation of function fields over QQ
  when initializing a maximal order, we need a monic integral model
    of the function field, either because the function field is
    already integral, or we create a model, call it's _maximal_order_basis()
    method, then map those basis elements back
  need FunctionField_integral in addition to (or instead of) FunctionField_global_integral
    computation of maximal order init routine uses a modified singular routine to compute normalization
    I think the modification is because it's hard to get singular results back to Sage
      when they're attached to a given ring; it's easiest to just write a new singular
      function that returns the results the way Sage likes them


HOW SAGE INITIALIZES atexit CALLBACKS

SageCustomizations in sage.repl.ipython_extensions
   __init__ calls self.set_quit_hook()
      which defines a quit function with atexit that calls sage.all.quit_sage()
      which calls expect_quitall() in sage.interfaces.quit

(Pdb) where
  /home/baccala/src/sage/src/bin/sage-ipython(15)<module>()
-> app.initialize()
  <decorator-gen-110>(2)initialize()
  /home/baccala/src/sage/local/lib/python2.7/site-packages/traitlets/config/application.py(87)catch_config_error()
-> return method(app, *args, **kwargs)
  /home/baccala/src/sage/local/lib/python2.7/site-packages/IPython/terminal/ipapp.py(316)initialize()
-> self.init_shell()
  /home/baccala/src/sage/local/lib/python2.7/site-packages/sage/repl/interpreter.py(762)init_shell()
-> self.shell.extension_manager.load_extension(SAGE_EXTENSION)
  /home/baccala/src/sage/local/lib/python2.7/site-packages/IPython/core/extensions.py(85)load_extension()
-> if self._call_load_ipython_extension(mod):
  /home/baccala/src/sage/local/lib/python2.7/site-packages/IPython/core/extensions.py(132)_call_load_ipython_extension()
-> mod.load_ipython_extension(self.shell)
  /home/baccala/src/sage/local/lib/python2.7/site-packages/sage/__init__.py(11)load_ipython_extension()
-> sage.repl.ipython_extension.load_ipython_extension(*args)
  /home/baccala/src/sage/local/lib/python2.7/site-packages/sage/repl/ipython_extension.py(564)wrapper()
-> result = func(*args, **kwargs)
  /home/baccala/src/sage/local/lib/python2.7/site-packages/sage/repl/ipython_extension.py(577)load_ipython_extension()
-> SageCustomizations(shell=ip)
> /home/baccala/src/sage/local/lib/python2.7/site-packages/sage/repl/ipython_extension.py(426)__init__()
-> self.auto_magics = SageMagics(shell)
(Pdb)
